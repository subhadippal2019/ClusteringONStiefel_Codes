{
    "contents" : "#' parametric mixture modeling of Matrix Langevin with fixed clusters\n#' @export\n#' @param data input-data coming from Stiefel array of 2D matrices data[,,i] is in V_{3,2}\n#' @param nc numer of clusters to fit the model\n#' @param max_iter total number of MCMC ierations\n#' @useDynLib ClusterOnStiefel\nfiniteMixtureML <- function(data,nc,max_iter=2,run_id=1){\n\n  #library(gtools)\n\n  set.seed(43185)\n\n  N = dim(data)[[3]]\n\n  vague_prior = 1\n  hyper = init_run(nc,vague_prior)\n  ########################\n\n  MCMC_sample = vector(\"list\", max_iter)\n\n  MCMC_output_file = sprintf(\"MCMC_sample_%d_%d.RData\",nc,run_id)\n  init_param_output_file = sprintf(\"init_param_MLE_%d_%d.RData\",nc,run_id)\n  ########### hyper parameters #######\n  ### need to select empirical prior\n#   hyper=NULL\n#   hyper$G = (matrix(c(0,0,0,0,0,0),ncol = 2))\n#   hyper$H = (matrix(c(0,0,0,0),ncol = 2))\n#   hyper$alpha = 1.0\n#   hyper$beta = 0.0\n#   hyper$dir_alpha = rep(0.0,nc)\n#   for (j in 1:nc)\n#     hyper$dir_alpha[j] = 1.0\n#\n  ####################################\n\n  #### initialization ####\n\n  ###curr_param = init_param_true(nc)\n  init_param = init_param_from_MLE(data,nc)\n  save(init_param_MLE=init_param,file=init_param_output_file)\n  ########################\n\n  curr_param = init_param\n  Z = curr_param$id_arr\n\n#   prob_vec = rep(1,nc)\n#   prob_vec = prob_vec/nc\n#   for (i in 1:N){\n#     r = rmultinom(1,1,prob_vec)\n#     Z[i] = which(r==1)\n#   }\n\n  ### prior for mixture weights\n  pi_vec = rep(1,nc)/nc\n  #pi_vec = rdirichlet(1,hyper$dir_alpha)\n  cluster_id_cnt = sapply(1:nc, function(x) sum(curr_param$id_arr == x))\n  pi_vec = rdirichlet(1,hyper$dir_alpha+cluster_id_cnt)\n\n  d_tmp_val = matrix(rep(0,N*nc),ncol=nc)\n\n  for(iter in 1:max_iter){\n    ######################\n    if(iter%%10 == 0){\n      print(paste0(\"MCMC main iter = \",iter))\n    }\n    ##### gibbs step #####\n    for (i in 1:N){\n      clust_assign_prob_i = rep(0,nc)\n      for (cluster_id in 1:nc){\n        d_tmp_val[i,cluster_id] = dMatrixLangevin(data[,,i],curr_param$M[,,cluster_id],curr_param$D[,,cluster_id],curr_param$V[,,cluster_id])\n\n        clust_assign_prob_i[cluster_id] = pi_vec[cluster_id]*d_tmp_val[i,cluster_id]\n      }\n      #clust_assign_prob_i = clust_assign_prob_i/sum(clust_assign_prob_i)\n      Z[i] = sample(1:nc,1,FALSE,clust_assign_prob_i)\n      #print(clust_assign_prob_i)\n    }\n    cluster_assign_vec = Z\n    #write.table(d_tmp_val,file=\"d_tmp_val.txt\")\n    #tmp_table = as.matrix(table(Z))\n    #cluster_id_cnt = cbind(as.integer(row.names(tmp_table)),tmp_table)\n    #cluster_id_cnt = rep(0,length(hyper$dir_alpha))\n\n    #for (cluster_id in 1:nc){\n    #  cluster_id_cnt[cluster_id] = sum(cluster_assign_vec == cluster_id)\n    #}\n    ## as an alternative to previous 3 statements\n    cluster_id_cnt = sapply(1:nc, function(x) sum(cluster_assign_vec == x))\n\n    #print(hyper$dir_alpha)\n    print(cluster_id_cnt)\n    pi_vec = rdirichlet(1,hyper$dir_alpha+cluster_id_cnt)\n\n    #### for all the clusters ####\n    #if(iter == 1){\n    #  load(\"ML_dataset.Rdata\")\n    #  curr_param = L$curr_param\n    #  cluster_assign_vec = L$clust\n    #}\n    curr_param = cluster_param_update(data, curr_param, cluster_assign_vec, cluster_id_vec=1:nc,hyper)\n\n    ### need to update with updated cluster_assign_vec\n    ##################################\n\n    print(paste0(\"Mixture modeling: MCMC iteration update \",iter))\n\n    MCMC_sample[[iter]]$curr_param = curr_param\n    MCMC_sample[[iter]]$pi_vec = pi_vec\n\n    if(iter%%100==0){\n      save(\"MCMC_sample\", file = MCMC_output_file)\n    }\n  }\n\n  #G = NULL\n  #G$curr_param = curr_param\n  #G$clust = cluster_assign_vec\n  #print(G$curr_param$D[,,1])\n\n  #return(G)\n  #save(D1_1,D2_1,D1_2,D2_2,D1_3,D2_3,file=\"D1_D2.Rdata\")\n  save(\"MCMC_sample\", file = MCMC_output_file)\n\n  return(MCMC_sample)\n}\n\n\ndMatrixLangevin <- function(X,M,D,V){\n\n  #dyn.load(\"./C_code/functions_hyper_2by2_R.so\")\n\n  F = M %*% D %*% V\n  D = diag(D)\n  eigenValues=D^2/4;\n  dRet = 0.0\n  ### normalizing constant\n  hyper0F1_val = .C(\"hyper_2by2_R\",a=1.5,eigenValues,dRet)[[3]]\n\n  ### compute density value\n  ML_density =exp(sum(diag(t(F)%*%X))) / hyper0F1_val\n\n  return(ML_density)\n\n}\n\n\ninit_run <-function(nc,vague_prior){\n  source(\"utility.R\")\n  load_src_libs()\n\n  hyper=NULL\n\n  if(vague_prior == 1){\n    hyper$G = (matrix(c(0,0,0,0,0,0),ncol = 2))\n    hyper$H = (matrix(c(0,0,0,0),ncol = 2))\n    hyper$alpha = 1.0\n    hyper$beta = 0.15 ###### note that, min 5 data made a cluster 5*0.01 = 0.05,\n                    ###### for N==1 if S>0.99 then distribution of d1 hv a heavy tail\n\n    hyper$dir_alpha = rep(0.0,nc)\n    for (j in 1:nc)\n      hyper$dir_alpha[j] = 1.0\n  } ## emperical\n\n\n  hyper$debug = 0\n\n  return(hyper)\n\n}\n",
    "created" : 1477889914568.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3694847012",
    "id" : "2DDDBD6A",
    "lastKnownWriteTime" : 1477890296,
    "path" : "~/Dropbox/ClusteringDTIonstiefel/DensitySVD_sep1_16/package_code/ClusterOnStiefel/R/finiteMixtureML.R",
    "project_path" : "R/finiteMixtureML.R",
    "properties" : {
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "type" : "r_source"
}