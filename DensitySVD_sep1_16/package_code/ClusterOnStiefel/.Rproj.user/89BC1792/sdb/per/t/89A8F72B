{
    "contents" : "rdensity_d1_d2<-function(D,S,dimIndex,N,nBin=10,sampleSize=1,hyper,kk){\n\n  ###################\n  ### Description:\n\n  ### this function is used for sampling d1 and d2 (depends on dimIndex = 1 or 2)\n  ### for d1: currently approximate mode of the distribution is searched and a\n  ### nearby value is returned by putting a grid between d2 to d2+3*|d2-mode|\n  ### for d2: value is returned by putting a grid in between 0 and d1\n\n  ####################\n\n  #print(paste0(\"inside rdensity_d1_d2\"))\n  ##out=density1(y=(1:8000)/200,D=c(0.7,5.4),S=c(14,15),1,10,1)\n  ##plot(exp(out-max(out)))\n  #dyn.load(\"./C_code/functions_hyper_2by2_R.so\")\n\n  #### y is the supprt of the distribution discretized in a grid\n  #### if dimIndex = 1 then we have to sample for d_1 (> d_2)\n  #### if dimIndex = 2 then we have to sample for d_2 (< d_1)\n  if(length(dim(D)) == 2 ){\n    D = diag(D)\n  }\n  if(length(dim(S)) == 2 ){\n    S = diag(S)\n  }\n  if(nBin > 100)\n  {\n    nBin = 100\n  }\n\n  alpha=hyper$alpha;\n  beta=hyper$beta;\n\n  #print(paste0(\"D[1] D[2] : \",D[1],\" \",D[2]))\n\n  if(dimIndex == 1 && (S[1]-beta) > 0) #### d_1 should be in d_2 to \\infty\n  {\n    print_debug(paste0(\"before NR \",D),hyper$debug)\n\n    d1_near_mode = NR_method_derivative_d1(D,S,dimIndex,N,max_iter=10,hyper) ##### replaced by NR method\n    if(d1_near_mode <= D[2]){\n      d1_near_mode = D[2]  ##### because support starts from D[2] and it is maximum at D[2]\n    }\n    #diff_from_d2 = abs(D[2]-d1_near_mode) #### how far should we search; need a lower bound\n    #pseudoInfty = D[2] + max(5,20*diff_from_d2)   #### totally adhoc\n    pseudoInfty = return_pseudoInfty(D,S,dimIndex,N,hyper,d1_near_mode) ### to be checked\n    #print(paste0(\"1. pseudoInfty = \",pseudoInfty))\n    y = seq(D[2],pseudoInfty,1/nBin)\n  }\n  #### in the following case when S[1] <= 0 then we don't need NR method\n  if(dimIndex == 1 && (S[1]-beta) <= 0) #### d_1 should be in d_2 to \\infty but as S[1] is negative so there is no mode so just sample near d2\n  {\n    pseudoInfty =  return_pseudoInfty(D,S,dimIndex,N,hyper,D[2])\n    #print(paste0(\"2. pseudoInfty = \",pseudoInfty))\n\n    #pseudoInfty = D[2] + 5   #### totally adhoc\n    y = seq(D[2],pseudoInfty,1/nBin)\n  }\n\n  if(dimIndex == 2) #### d_2 should be 0 to d_1\n  {\n    if(D[1] <= 1/nBin)\n    {\n      nBin = 100*nBin\n    }\n    y = seq(1/nBin,D[1],1/nBin)\n  }\n\n  val=0*seq(1:length(y));\n\n  for (i in  1:length(y)){\n\n    x=y[i];\n\n    D[dimIndex]=x;\n    eigenValues=D^2/4;\n    d = 0.0\n    bLog = 1 ### hard-coded to avoid problem\n    if(bLog==1){\n      hyper0F1_val = .C(\"hyper_2by2_R\",a=1.5,eigenValues,d)[[3]]\n      val[i]=(alpha-1)*log(x)+(x*(S[dimIndex]-beta))- N * log(hyper0F1_val)\n    }else{\n      hyper0F1_val = .C(\"hyper_2by2_R\",a=1.5,eigenValues,d)[[3]]\n      val[i]=x^(alpha-1)*exp(x*(S[dimIndex]-beta))/(hyper0F1_val)^N\n    }\n\n  }\n  #print_debug(val,hyper$debug)\n  #write.table(val,file=\"./rdensity_d1_d2.txt\")\n  prob=exp(val-max(val))\n  #if(dimIndex >= 1){\n  #  plot(y,prob,type='l',main=paste0('cluster ',kk,' d',dimIndex)) ### ploting (optional)\n  #}\n\n  S1=y[which(prob>0)]\n  prob1=prob[which(prob>0)]\n  #S1\n  x=sample(S1, size=sampleSize, replace = TRUE, prob = prob1)\n\n  return(x)\n\n}\n\nreturn_pseudoInfty <- function(D,S,dimIndex,N,hyper,d1_near_mode){\n\n  epsilon = 0.001\n  dist_1 = 5\n  MAX_ITER = 6\n\n  #print(paste0(\"************* IN THE FUNCTION ******\"))\n  #print(paste0(\"near mode = \",d1_near_mode))\n  #diff_from_d2 = abs(D[2]-d1_near_mode)\n  #tmp1 = D[2] + max(5,20*diff_from_d2)\n\n\n  d_tmp1 = d_density_d1_log(d1_near_mode,D,S,dimIndex,N,hyper,bLog=1)\n  prop_d1_end = d1_near_mode + dist_1\n  d_tmp2 = d_density_d1_log(prop_d1_end,D,S,dimIndex,N,hyper,bLog=1)\n  diff_ratio = exp(d_tmp2-d_tmp1)\n\n  print_debug(paste0(\"d1_near_mode = \",d1_near_mode,\" prop_d1_end = \",prop_d1_end),hyper$debug)\n  print_debug(paste0(\"d_density_d1_log (near_mode) = \", d_tmp1, \" d_density_d1_log (right_tail) = \",d_tmp2),hyper$debug)\n  cnt_inr = 1\n\n  print_debug(paste0(\"cnt\", cnt_inr, \" diff_ratio = \",diff_ratio),hyper$debug)\n  while((diff_ratio > epsilon) && (cnt_inr < MAX_ITER)){\n    prop_d1_end = d1_near_mode + (2*cnt_inr)*dist_1\n    d_tmp2 = d_density_d1_log(prop_d1_end,D,S,dimIndex,N,hyper,bLog=1)\n    diff_ratio = exp(d_tmp2-d_tmp1)\n    cnt_inr = cnt_inr + 1\n    print_debug(paste0(\"cnt\", cnt_inr, \" diff_ratio = \",diff_ratio),hyper$debug)\n  }\n  return(prop_d1_end)\n}\n\n#' function to return log density for D[1]\n#' out=d_density_d1_log(y=(1:4000)/2000,D=c(0.7,5.4),S=c(7,8),1,10,hyper,1)\n#' plot(exp(out-max(out)),type='l')\n\n#' @export\nd_density_d1_log<-function(y,D,S,dimIndex,N,hyper=NULL,bLog=1){\n\n  ##out=d_density_d1_log(y=(1:4000)/2000,D=c(0.7,5.4),S=c(7,8),1,10,hyper,1)\n  ##plot(exp(out-max(out)),type='l')\n\n  #dyn.load(\"./C_code/functions_hyper_2by2_R.so\")\n\n  if(is.null(hyper)){\n    hyper$alpha = 1.0\n    hyper$beta = 0.05\n  }\n\n  val=0*seq(1:length(y));\n\n  for (i in  1:length(y)){\n\n    x=y[i];\n    alpha=hyper$alpha;\n    beta=hyper$beta;\n    D[dimIndex]=x;\n    eigenValues=D^2/4;\n    d = 0.0\n    if(bLog==1){\n      hyper0F1_val = .C(\"hyper_2by2_R\",a=1.5,eigenValues,d)[[3]]\n      val[i]=(alpha-1)*log(x)+(x*(S[dimIndex]-beta))- N * log(hyper0F1_val)\n\n    }else{\n      hyper0F1_val = .C(\"hyper_2by2_R\",a=1.5,eigenValues,d)[[3]]\n      val[i]=x^(alpha-1)*exp(x*(S[dimIndex]-beta))/(hyper0F1_val)^N\n    }\n\n  }\n  #write.table(val,file=\"./density1.txt\")\n\n  return(val)\n\n}\n",
    "created" : 1477890671701.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "735129177",
    "id" : "89A8F72B",
    "lastKnownWriteTime" : 1477891175,
    "path" : "~/Dropbox/ClusteringDTIonstiefel/DensitySVD_sep1_16/package_code/ClusterOnStiefel/R/rdensity_d1_d2.R",
    "project_path" : "R/rdensity_d1_d2.R",
    "properties" : {
    },
    "relative_order" : 2,
    "source_on_save" : false,
    "type" : "r_source"
}